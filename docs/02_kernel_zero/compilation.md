# Eidos Zero: Compilation (The Middle-end)

## 1. From AST to IR

Once the AST is validated, it is passed to the **Compiler**. The compiler's job is to translate the abstract graph into a concrete execution plan.

### 1.1 The Substrait Bridge
Eidos uses **Substrait** (Cross-Language Serialization for Relational Algebra) as its intermediate representation.
*   **Why?** It decouples the frontend (Python) from the backend (Rust/C++).
*   **Benefit**: A plan generated by Eidos can be executed by *any* Substrait-compatible engine (DuckDB, Velox, etc.), ensuring future-proofing.

## 2. Optimization Passes

Before code generation, the IR goes through several optimization passes.

### 2.1 Fusion (Operator Fusion)
*   **Concept**: Merging adjacent operations to reduce memory overhead.
*   **Logic**: `Map(f) >> Map(g)` becomes `Map(g âˆ˜ f)`.
*   **Benefit**: Eliminates intermediate materialization. Instead of `Loop 1 -> List 1 -> Loop 2 -> List 2`, we get `Loop 1 -> f -> g -> List 2`.
*   **Polars Backend**: This happens natively via `LazyFrame` optimization.

### 2.2 Pushdown (Predicate & Projection Pushdown)
*   **Concept**: Moving filters and column selections as close to the source as possible.
*   **Logic**: `Source(DB) >> Filter(x > 5)` becomes `Source(DB, query="SELECT * WHERE x > 5")`.
*   **Benefit**: Drastically reduces I/O and network traffic.
*   **DolphinDB Adapter**: This pass is critical. It translates `Filter` nodes into SQL `WHERE` clauses and `Project` nodes into `SELECT` lists.

### 2.3 Pruning (Dead Code Elimination)
*   **Concept**: Removing branches that do not affect the final output.
*   **Logic**: If `A` splits into `B` and `C`, but only `C` connects to a Sink, `B` is pruned.

## 3. Transpilation Strategies

The final stage is **Transpilation**, where the optimized IR is converted into backend-specific instructions.

### 3.1 To Polars (Vector Lane)
The compiler generates a `polars.LazyFrame` object.
```python
# AST
Source("data") >> Filter(x > 5) >> Mean()

# Polars Code
pl.scan_parquet("data").filter(pl.col("x") > 5).select(pl.mean("x"))
```

### 3.2 To Ray (Cluster Lane)
The compiler partitions the DAG into **Stages** at shuffle boundaries (e.g., `Group`, `Join`, `Sort`).
1.  **Stage 1**: Source -> Map -> Filter (Local Task)
2.  **Shuffle**: Redistribution via Ray Object Store.
3.  **Stage 2**: Reduce -> Sink (Local Task)

```python
# Ray Code
ds = ray.data.read_parquet("data")
ds = ds.filter(lambda r: r["x"] > 5) # Stage 1
ds = ds.mean("x")                    # Stage 2
```

### 3.3 To SQL (Pushdown Lane)
The compiler generates ANSI SQL or dialect-specific SQL (e.g., DolphinDB script).
```sql
-- DolphinDB Code
select avg(x) from loadTable("dfs://db", "data") where x > 5
```

## 4. UDF Serialization (The "Free Lane")

When Python UDFs are unavoidable (e.g., `Map(lambda x: complex_logic(x))`), the compiler uses `cloudpickle` to serialize the function and its closure.
*   **No-GIL Mode**: On Python 3.14, these serialized functions are executed in parallel threads without the Global Interpreter Lock.
